/**
 * Security Scanner - Automated Security Testing Tool
 * Runs comprehensive security tests and generates reports
 * 
 * Usage: npx ts-node src/tests/security/pentest/security-scanner.ts
 */

import axios, { AxiosInstance, AxiosResponse } from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import securityConfig from '../config';
import { sqlInjectionPayloads, xssPayloads, commandInjectionPayloads, pathTraversalPayloads } from '../utils/payloads';

interface ScanResult {
    endpoint: string;
    method: string;
    vulnerability: string;
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
    evidence: string;
    remediation: string;
    cwe?: string;
    owasp?: string;
    timestamp: string;
}

interface ScanReport {
    scanId: string;
    startTime: string;
    endTime: string;
    target: string;
    totalEndpoints: number;
    totalVulnerabilities: number;
    bySeverity: {
        critical: number;
        high: number;
        medium: number;
        low: number;
        info: number;
    };
    findings: ScanResult[];
}

export class SecurityScanner {
    private client: AxiosInstance;
    private findings: ScanResult[] = [];
    private config = securityConfig;
    private startTime: Date = new Date();

    constructor(baseURL?: string) {
        this.client = axios.create({
            baseURL: baseURL || this.config.targets.backend,
            timeout: this.config.timing.requestTimeout,
            validateStatus: () => true, // Accept all status codes
        });
    }

    // ============================================
    // Authentication Helpers
    // ============================================
    private getTestHeaders(role: 'superadmin' | 'admin' | 'user' = 'admin') {
        const user = this.config.testUsers[role];
        return {
            'x-user-id': user.id.toString(),
            'x-user-role': user.role,
        };
    }

    // ============================================
    // SQL Injection Scanner
    // ============================================
    async scanSqlInjection(endpoint: string, paramName: string, method: 'GET' | 'POST' = 'GET'): Promise<void> {
        console.log(`\nüîç Scanning SQL Injection: ${method} ${endpoint}`);

        const payloads = [
            ...sqlInjectionPayloads.classic.slice(0, 5),
            ...sqlInjectionPayloads.union.slice(0, 3),
            ...sqlInjectionPayloads.timeBased.slice(0, 2),
        ];

        for (const payload of payloads) {
            try {
                let response: AxiosResponse;
                const startTime = Date.now();

                if (method === 'GET') {
                    response = await this.client.get(`${endpoint}?${paramName}=${encodeURIComponent(payload)}`, {
                        headers: this.getTestHeaders(),
                    });
                } else {
                    response = await this.client.post(endpoint, {
                        [paramName]: payload,
                    }, {
                        headers: this.getTestHeaders(),
                    });
                }

                const responseTime = Date.now() - startTime;
                const responseBody = JSON.stringify(response.data || '').toLowerCase();

                // Check for SQL error indicators
                const sqlErrors = [
                    'sql syntax', 'mysql', 'postgresql', 'sqlite',
                    'oracle', 'sqlserver', 'syntax error', 'query',
                    'unclosed quotation', 'sql error'
                ];

                const hasError = sqlErrors.some(err => responseBody.includes(err));
                const timeBasedSuspect = responseTime > 5000; // Time-based detection

                if (hasError) {
                    this.addFinding({
                        endpoint,
                        method,
                        vulnerability: 'SQL Injection - Error Based',
                        severity: 'CRITICAL',
                        evidence: `SQL error exposed with payload: ${payload.substring(0, 50)}`,
                        remediation: 'Use parameterized queries (Prisma handles this). Review raw query usage.',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021',
                    });
                }

                if (timeBasedSuspect) {
                    this.addFinding({
                        endpoint,
                        method,
                        vulnerability: 'SQL Injection - Time Based',
                        severity: 'CRITICAL',
                        evidence: `Response took ${responseTime}ms with payload: ${payload.substring(0, 50)}`,
                        remediation: 'Use parameterized queries. Review raw query usage.',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021',
                    });
                }
            } catch (error) {
                // Ignore network errors during scanning
            }
        }
    }

    // ============================================
    // XSS Scanner
    // ============================================
    async scanXss(endpoint: string, paramName: string, method: 'GET' | 'POST' = 'GET'): Promise<void> {
        console.log(`\nüîç Scanning XSS: ${method} ${endpoint}`);

        const payloads = [
            ...xssPayloads.basic.slice(0, 5),
            ...xssPayloads.eventHandlers.slice(0, 3),
            ...xssPayloads.encodingBypass.slice(0, 3),
        ];

        for (const payload of payloads) {
            try {
                let response: AxiosResponse;

                if (method === 'GET') {
                    response = await this.client.get(`${endpoint}?${paramName}=${encodeURIComponent(payload)}`, {
                        headers: this.getTestHeaders(),
                    });
                } else {
                    response = await this.client.post(endpoint, {
                        [paramName]: payload,
                    }, {
                        headers: this.getTestHeaders(),
                    });
                }

                const responseBody = JSON.stringify(response.data || '');

                // Check if payload is reflected
                if (responseBody.includes(payload)) {
                    this.addFinding({
                        endpoint,
                        method,
                        vulnerability: 'Cross-Site Scripting (XSS) - Reflected',
                        severity: 'HIGH',
                        evidence: `XSS payload reflected: ${payload.substring(0, 50)}`,
                        remediation: 'Encode output. Use Content-Type: application/json. Implement CSP.',
                        cwe: 'CWE-79',
                        owasp: 'A03:2021',
                    });
                }
            } catch (error) {
                // Ignore network errors
            }
        }
    }

    // ============================================
    // Authentication Scanner
    // ============================================
    async scanAuthentication(): Promise<void> {
        console.log('\nüîç Scanning Authentication Security');

        const loginEndpoint = this.config.endpoints.auth.login;

        // 1. Brute Force Protection
        let rateLimited = false;
        for (let i = 0; i < 20; i++) {
            const response = await this.client.post(loginEndpoint, {
                email: 'bruteforce@test.com',
                password: 'wrongpassword',
            });

            if (response.status === 429) {
                rateLimited = true;
                break;
            }
        }

        if (!rateLimited) {
            this.addFinding({
                endpoint: loginEndpoint,
                method: 'POST',
                vulnerability: 'Missing Brute Force Protection',
                severity: 'HIGH',
                evidence: '20 failed login attempts without rate limiting',
                remediation: 'Implement rate limiting on login endpoint',
                cwe: 'CWE-307',
                owasp: 'A07:2021',
            });
        }

        // 2. Username Enumeration
        const existingUserResponse = await this.client.post(loginEndpoint, {
            email: this.config.testUsers.admin.email,
            password: 'wrongpassword',
        });

        const nonExistingUserResponse = await this.client.post(loginEndpoint, {
            email: 'nonexistent@test.com',
            password: 'wrongpassword',
        });

        if (existingUserResponse.status !== nonExistingUserResponse.status ||
            JSON.stringify(existingUserResponse.data).length !== JSON.stringify(nonExistingUserResponse.data).length) {
            this.addFinding({
                endpoint: loginEndpoint,
                method: 'POST',
                vulnerability: 'Username Enumeration',
                severity: 'MEDIUM',
                evidence: 'Different responses for existing vs non-existing users',
                remediation: 'Return consistent error messages regardless of user existence',
                cwe: 'CWE-204',
                owasp: 'A01:2021',
            });
        }
    }

    // ============================================
    // Authorization Scanner (IDOR)
    // ============================================
    async scanAuthorization(): Promise<void> {
        console.log('\nüîç Scanning Authorization (IDOR)');

        const userHeaders = this.getTestHeaders('user');
        const victimId = 1;

        // 1. User Data IDOR
        const userDataResponse = await this.client.get(`/api/users/${victimId}`, {
            headers: userHeaders,
        });

        if (userDataResponse.status === 200) {
            this.addFinding({
                endpoint: `/api/users/${victimId}`,
                method: 'GET',
                vulnerability: 'Insecure Direct Object Reference (IDOR)',
                severity: 'HIGH',
                evidence: 'Regular user can access other users\' data',
                remediation: 'Implement proper access control. Check ownership before returning data.',
                cwe: 'CWE-639',
                owasp: 'A01:2021',
            });
        }

        // 2. User Modification IDOR
        const modifyResponse = await this.client.put(`/api/users/${victimId}`, {
            name: 'Hacked',
        }, {
            headers: userHeaders,
        });

        if (modifyResponse.status === 200) {
            this.addFinding({
                endpoint: `/api/users/${victimId}`,
                method: 'PUT',
                vulnerability: 'IDOR - Privilege Escalation',
                severity: 'CRITICAL',
                evidence: 'Regular user can modify other users\' data',
                remediation: 'Implement proper access control. Verify user owns the resource.',
                cwe: 'CWE-639',
                owasp: 'A01:2021',
            });
        }
    }

    // ============================================
    // Security Headers Scanner
    // ============================================
    async scanSecurityHeaders(): Promise<void> {
        console.log('\nüîç Scanning Security Headers');

        const response = await this.client.get('/api/health');

        const requiredHeaders = [
            { name: 'x-content-type-options', expected: 'nosniff', severity: 'MEDIUM' as const },
            { name: 'x-frame-options', expected: ['DENY', 'SAMEORIGIN'], severity: 'MEDIUM' as const },
            { name: 'strict-transport-security', expected: null, severity: 'MEDIUM' as const },
        ];

        const warningHeaders = [
            { name: 'x-powered-by', shouldNotExist: true, severity: 'LOW' as const },
        ];

        for (const header of requiredHeaders) {
            const value = response.headers[header.name];
            if (!value) {
                this.addFinding({
                    endpoint: '/api/health',
                    method: 'GET',
                    vulnerability: `Missing Security Header: ${header.name}`,
                    severity: header.severity,
                    evidence: `${header.name} header is not present`,
                    remediation: `Add ${header.name} header. Use Helmet.js for Express.`,
                    cwe: 'CWE-693',
                    owasp: 'A05:2021',
                });
            }
        }

        for (const header of warningHeaders) {
            const value = response.headers[header.name];
            if (value && header.shouldNotExist) {
                this.addFinding({
                    endpoint: '/api/health',
                    method: 'GET',
                    vulnerability: `Information Disclosure: ${header.name}`,
                    severity: header.severity,
                    evidence: `${header.name}: ${value}`,
                    remediation: `Remove ${header.name} header to prevent information disclosure`,
                    cwe: 'CWE-200',
                    owasp: 'A05:2021',
                });
            }
        }
    }

    // ============================================
    // Path Traversal Scanner
    // ============================================
    async scanPathTraversal(endpoint: string): Promise<void> {
        console.log(`\nüîç Scanning Path Traversal: ${endpoint}`);

        for (const payload of pathTraversalPayloads.slice(0, 10)) {
            try {
                const response = await this.client.get(`${endpoint}/${encodeURIComponent(payload)}`, {
                    headers: this.getTestHeaders(),
                });

                const body = JSON.stringify(response.data || '').toLowerCase();

                // Check for file content indicators
                if (body.includes('root:') || body.includes('[extensions]') ||
                    body.includes('boot.ini') || body.includes('passwd')) {
                    this.addFinding({
                        endpoint: `${endpoint}/${payload}`,
                        method: 'GET',
                        vulnerability: 'Path Traversal',
                        severity: 'CRITICAL',
                        evidence: `File content leaked with payload: ${payload}`,
                        remediation: 'Validate and sanitize file paths. Use path.basename(). Avoid user input in file paths.',
                        cwe: 'CWE-22',
                        owasp: 'A01:2021',
                    });
                    break;
                }
            } catch (error) {
                // Ignore errors
            }
        }
    }

    // ============================================
    // Helpers
    // ============================================
    private addFinding(finding: Omit<ScanResult, 'timestamp'>): void {
        const result: ScanResult = {
            ...finding,
            timestamp: new Date().toISOString(),
        };
        this.findings.push(result);
        console.log(`  ‚ö†Ô∏è  Found: ${finding.vulnerability} [${finding.severity}]`);
    }

    // ============================================
    // Run Full Scan
    // ============================================
    async runFullScan(): Promise<ScanReport> {
        this.startTime = new Date();
        console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë         HR-IMS Security Scanner v1.0             ‚ïë');
        console.log('‚ïë         Automated Penetration Testing            ‚ïë');
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
        console.log(`\nüéØ Target: ${this.config.targets.backend}`);
        console.log(`üìÖ Scan Started: ${this.startTime.toISOString()}\n`);

        // Run all scans
        await this.scanAuthentication();
        await this.scanAuthorization();
        await this.scanSecurityHeaders();

        // Scan endpoints for injection
        const endpoints = [
            { url: '/api/inventory', param: 'search', methods: ['GET'] },
            { url: '/api/users', param: 'search', methods: ['GET'] },
        ];

        for (const ep of endpoints) {
            await this.scanSqlInjection(ep.url, ep.param, 'GET');
            await this.scanXss(ep.url, ep.param, 'GET');
        }

        await this.scanPathTraversal('/api/files');

        return this.generateReport();
    }

    // ============================================
    // Generate Report
    // ============================================
    generateReport(): ScanReport {
        const endTime = new Date();

        const report: ScanReport = {
            scanId: `SCAN-${Date.now()}`,
            startTime: this.startTime.toISOString(),
            endTime: endTime.toISOString(),
            target: this.config.targets.backend,
            totalEndpoints: 10, // Approximate
            totalVulnerabilities: this.findings.length,
            bySeverity: {
                critical: this.findings.filter(f => f.severity === 'CRITICAL').length,
                high: this.findings.filter(f => f.severity === 'HIGH').length,
                medium: this.findings.filter(f => f.severity === 'MEDIUM').length,
                low: this.findings.filter(f => f.severity === 'LOW').length,
                info: this.findings.filter(f => f.severity === 'INFO').length,
            },
            findings: this.findings,
        };

        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('               SCAN SUMMARY');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log(`Scan ID: ${report.scanId}`);
        console.log(`Duration: ${(endTime.getTime() - this.startTime.getTime()) / 1000}s`);
        console.log(`Total Vulnerabilities Found: ${report.totalVulnerabilities}`);
        console.log(`  üî¥ Critical: ${report.bySeverity.critical}`);
        console.log(`  üü† High: ${report.bySeverity.high}`);
        console.log(`  üü° Medium: ${report.bySeverity.medium}`);
        console.log(`  üîµ Low: ${report.bySeverity.low}`);
        console.log(`  ‚ö™ Info: ${report.bySeverity.info}`);
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

        return report;
    }

    // ============================================
    // Save Report to File
    // ============================================
    saveReportToFile(report: ScanReport, outputDir?: string): string {
        const dir = outputDir || this.config.reporting.outputDir;
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        const filename = `security-scan-${report.scanId}.json`;
        const filepath = path.join(dir, filename);

        fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
        console.log(`üìÑ Report saved to: ${filepath}`);

        return filepath;
    }
}

// ============================================
// CLI Runner
// ============================================
if (require.main === module) {
    const scanner = new SecurityScanner();

    scanner.runFullScan()
        .then(report => {
            scanner.saveReportToFile(report);
            process.exit(report.bySeverity.critical > 0 ? 1 : 0);
        })
        .catch(error => {
            console.error('Scan failed:', error);
            process.exit(1);
        });
}
